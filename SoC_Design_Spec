# RV32I FPGA SoC — Design Specification (v0)

## 1. Purpose and Scope

This document specifies the architecture and functionality of a custom **FPGA-based System-on-Chip (SoC)** implementing a **RISC-V RV32I subset CPU**, intended for educational and portfolio demonstration purposes. The SoC targets implementation on an **Intel MAX 10 (10M50)** FPGA and emphasizes clarity, debuggability, and architectural correctness over performance.

The design is **FPGA-only** and does not target ASIC fabrication at this stage.

ASIC fabrication will be attempted in the future.

---

## 2. High-Level Architecture Overview

The SoC consists of:

* A **multi-cycle RV32I CPU core**
* **Harvard architecture** memory system
* A **memory-mapped peripheral bus**
* On-chip peripherals (UART, GPIO, Timer)
* External interaction via UART and GPIO

Instruction execution, memory access, and peripheral control are all visible and deterministic.

---

## 3. Architectural Decisions (Locked)

### 3.1 CPU Architecture

* ISA: **RISC-V RV32I subset**
* Execution model: **Multi-cycle**
* Addressing: **Byte-addressed**
* Register file:

  * 32 general-purpose registers
  * `x0` hardwired to zero
* PC behavior:

  * 32-bit PC
  * Increments by 4 bytes
* No pipelining
* No cache
* No virtual memory

---

### 3.2 Memory Architecture (Harvard)

Instruction and data memories are separate and accessed through independent interfaces.

#### Instruction Memory (IMEM)

* Read-only
* Local to CPU
* Pre-initialized at FPGA build time
* No instruction fetch stalls

#### Data Memory (DMEM)

* Read/write
* Accessed via SoC data bus
* Shared address space with memory-mapped peripherals

---

## 4. Memory Map

### 4.1 Instruction Memory

* Base address: `0x0000_0000`
* Size: **16 KB**
* Address range: `0x0000_0000 – 0x0000_3FFF`
* Addressed by PC (byte-addressed, word-aligned)

---

### 4.2 Data Memory

* Base address: `0x1000_0000`
* Size: **8 KB**
* Address range: `0x1000_0000 – 0x1000_1FFF`
* Word-aligned accesses only (initially)

---

### 4.3 Memory-Mapped I/O (MMIO)

* Base address: `0x2000_0000`
* Peripherals are mapped at fixed offsets within this region.

| Peripheral     | Base Address  |
| -------------- | ------------- |
| UART           | `0x2000_0000` |
| GPIO           | `0x2000_1000` |
| Timer          | `0x2000_2000` |
| Debug / Status | `0x2000_F000` |

---

## 5. Peripheral Specifications (Minimal v0)

### 5.1 UART (Polling-based)

Used for console I/O and debugging.

| Offset | Name   | Access | Description              |
| ------ | ------ | ------ | ------------------------ |
| `0x00` | TXDATA | W      | Write byte to transmit   |
| `0x04` | RXDATA | R      | Read received byte       |
| `0x08` | STATUS | R      | TX_READY, RX_VALID flags |

* Baud rate fixed or configurable (TBD)
* No interrupts initially

---

### 5.2 GPIO

Used for LEDs, switches, and simple external I/O.

| Offset | Name | Access | Description                  |
| ------ | ---- | ------ | ---------------------------- |
| `0x00` | OUT  | R/W    | Output value                 |
| `0x04` | IN   | R      | Input value                  |
| `0x08` | DIR  | R/W    | Direction control (optional) |

---

### 5.3 Timer

Used for timekeeping and periodic events.

| Offset | Name        | Access | Description        |
| ------ | ----------- | ------ | ------------------ |
| `0x00` | COUNT       | R      | Current count      |
| `0x04` | COMPARE     | W      | Compare value      |
| `0x08` | CTRL/STATUS | R/W    | Enable, flag clear |

---

## 6. Bus Interface Specification

The CPU accesses DMEM and MMIO through a simple internal bus.

### 6.1 Bus Characteristics

* Single master (CPU)
* Multiple slaves (DMEM, peripherals)
* Word-aligned accesses only
* Fixed-latency or ready/valid handshake (TBD)

### 6.2 Bus Signals (Conceptual)

* Address
* Write data
* Read data
* Read enable
* Write enable
* Ready / acknowledge

---

## 7. Instruction Set (Phase 1 Subset)

### 7.1 Implemented Instructions

**Arithmetic / Immediate**

* `ADDI`
* `ADD`, `SUB`
* `AND`, `OR`, `XOR` (optional early)

**Memory**

* `LW`
* `SW`

**Control Flow**

* `BEQ`, `BNE`
* `JAL`
* `JALR`
* `LUI`

**System**

* `NOP`
* Custom `HALT` instruction (non-standard)

### 7.2 Not Implemented (v0)

* Interrupts / exceptions
* CSRs
* Compressed instructions
* Multiply/divide
* Byte/halfword loads
* Misaligned accesses

---

## 8. Reset and Boot Behavior

* On reset:

  * PC = `0x0000_0000`
  * CPU begins fetching from IMEM
  * Peripherals reset to known state
* Program execution begins immediately after reset
* No bootloader (IMEM pre-initialized)

---

## 9. Debug and Observability

* UART used for software-visible debugging
* GPIO may be used for hardware status indication
* Optional debug/status register block reserved

---

## 10. Design Constraints and Goals

* Single clock domain
* Target clock: board oscillator (e.g., 50 MHz)
* Synthesis-friendly RTL (no vendor primitives in logic)
* Parameterized memory sizes
* Clear separation of datapath and control

---

## 11. Out of Scope (for this phase)

* ASIC hardening
* Power management
* Security features
* High-performance optimizations

---

## 12. Success Criteria

The design is considered successful when:

1. The CPU boots from IMEM
2. A program executes and manipulates memory
3. UART output is visible on a PC terminal
4. GPIO outputs respond to software control
5. The system runs reliably on FPGA hardware

---

### Why this matters

This document is now your **design contract**:

* RTL must match it
* Tests validate it
* Future enhancements extend it

If you want, the **next natural step** is to:

* turn this into a **block diagram** that exactly mirrors the spec, or
* derive a **module list** directly from this document (one module per section).

Tell me which you want to do next.
